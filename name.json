{
  "id": 0,
  "tagName": "综合",
  "cTime": "2024-04-21T13:31:16.000Z",
  "uTime": null,
  "disabled": 1,
  "posts": [
    {
      "articleId": 48,
      "articles": {
        "id": 48,
        "title": "js 类数组",
        "text": "-\n- 什么是类数组，一开始我是懵逼的，直到我要学习ts才知道类数组这个东西\n\n> 类数组：是一种相似数组的对象，并提供了一种用于访问原始二进制数据的机制，但不是真正的数组。js 中类数组对象有不少，例如`arguments`、 `NodeList`、 `HTMLCollection`、 `jQuery`等\n\n---\n\n> 类数组拥有的特性\n\n1. length\n\n   ```\n   const a = document.getElementsByTagName(\"div\")\n   a.length\n   ```\n\n<!---->\n\n2. 能够使用数字下标方式访问对象\n\n   ```\n   a[0]; // <div id=\"app\"></div>\n   ```\n\n<!---->\n\n3. 不能使用数组原型方法，如slice、pop等\n\n   ```\n   a.push(0) // 报错\n   ```\n\n<!---->\n\n4. 使用 `instanceof` 操做不属于 `Array`\n\n   ```\n   a instanceof Array; // false\n   a instanceof Object; // true\n   ```\n\n<!---->\n\n5. 能够被转换为真数组\n\n   ```\n   const arr = Array.from(a)\n   arr instanceof Array; // true\n   ```\n\n<!---->\n\n6. 可自定义其余属性\n\n   ```\n   a.name = '666'\n   ```\n\n> arguments 类对象\n>\n> ```\n> function fn() {\n>   console.log(arguments) // [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4 }\n> }\n> fn(1,2,3,4)\n> ```\n",
        "date": "2024-04-13T16:26:03.000Z",
        "remark": null,
        "authId": 1,
        "abstract": "\n\n什么是类数组，一开始我是懵逼的，直到我要学习ts才知道类数组这个东西\n\n\n类数组：是一种相似数组的对象，并提供了一种用于访问原始二进制数据的机制，但不是真正的数组。js 中类数组对象有不少，例如a...",
        "tags": "1",
        "disabled": 1
      },
      "categoryId": 0
    },
    {
      "articleId": 49,
      "articles": {
        "id": 49,
        "title": "qiankun微前端的初使用",
        "text": "> 微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\n> 微前端借鉴了微服务的架构理念，将一个庞大的前端应用拆分为多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用联合为一个完整的应用。微前端既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性，相比一整块的前端仓库，微前端架构下的前端仓库倾向于更小更灵活。\n\n### 主应用\n\n> 安装\n\n```bash\nnpm i qiankun -S\n```\n\n> [registerMicroApps](https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles)方法，新建一个hooks文件，生成一个usehooks供全局使用，然后在需要微前端的地方调用即可\n\n* 当路由跳转匹配上qiankun配置的规则时，则会跳转到子应用的路由如（/one/pagesone）则匹配子应用的pagesone的路由\n\n```javascript\nimport { registerMicroApps, runAfterFirstMounted, start } from \"qiankun/es\"\nimport { RegistrableApp } from \"qiankun\"\n\nexport const useQiankun = () => {\n    // const app = [\n    //     {\n    //     name: 'ms-one', // 微应用的名称\n    //     entry: 'http://localhost:3001/', // 微应用的入口\n    //     container: '#one-container', // 微应用的容器节点的选择器\n    //     activeRule: '/one' // 微应用的激活规则匹配路由规则\n    //   }]\n    const initQiankun = (app: Array<RegistrableApp<Record<string, unknown>>>, mounted = () => {}) => {\n      registerMicroApps(app, {})\n      // 第一个微应用 mount 后需要调用的方法，比如开启一些监控或者埋点脚本 \n      runAfterFirstMounted(() => {\n        mounted()\n      })\n      start({ prefetch: true }) // 启动\n    }\n    return { initQiankun }\n}\n```\n\n##### 使用\n\n> 对应的页面创建dom、生成对应的app\n\n```vue\n<script lang=\"ts\" setup>\nimport { onMounted } from 'vue'\nimport { useQiankun } from './hooks/useQiankun'\nconst app = [\n  {\n  name: 'ms-one',\n  entry: 'http://localhost:3001/',\n  container: '#one-container',\n  activeRule: '/one'\n}]\nconst { initQiankun } = useQiankun()\nonMounted(() => {\n  initQiankun(app)\n})\n\n</script>\n\n<template>\n  <div class=\"app-one-container\">\n    <div id=\"one-container\"></div>\n  </div>\n</template>\n```\n\n### 子应用\n\n> 安装vite的插件 vite-plugin-qiankun\n\n```bash\nnpm i vite-plugin-qiankun -D\n```\n\n> vite.config.ts中配置\n\n```javascript\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport path from 'path'\nimport Pages from 'vite-plugin-pages'\nimport qiankun from \"vite-plugin-qiankun\"\n\nexport default defineConfig({\n  plugins: [\n    vue(),\n    Pages({\n      dirs: 'src/views'\n    }),\n    qiankun(\"ms-one\", {\n      useDevMode: true\n    })\n  ],\n\n  base: \"/ms-one/\",\n\n  server: {\n    port: 3001\n  },\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"src\")\n    }\n  }\n})\n\n```\n\n> mian.js 中监听是子应用使用还是主应用过来\n\n```javascript\nimport { createApp } from 'vue'\nimport '@/assets/style.css'\nimport App from './App.vue'\nimport { createWebHistory } from 'vue-router'\nimport createRouter from \"./router\"\nimport { renderWithQiankun, qiankunWindow } from 'vite-plugin-qiankun/dist/helper'\n\nlet router: any = null\nlet instance: any = null\nlet history: any = null\n\nfunction render(props: any | undefined) {\n  console.log(\"__POWERED_BY_QIANKUN__\", qiankunWindow.__POWERED_BY_QIANKUN__)\n  const container = props ? props.container : undefined\n  history = createWebHistory(qiankunWindow.__POWERED_BY_QIANKUN__ ? '/one' : '/ms-one')\n  router = createRouter(history)\n  instance = createApp(App)\n  instance.use(router)\n  instance.mount(container ? container.querySelector('#app') : '#app')\n}\nrenderWithQiankun({\n  mount(props: any) {\n    render(props)\n    instance.config.globalProperties.$onGlobalStateChange = props.onGlobalStateChange\n    instance.config.globalProperties.$setGlobalState = props.setGlobalState\n  },\n  bootstrap() {\n    console.log('%c%s', 'color: green;', 'vue3.0 app bootstraped')\n  },\n  unmount() {\n    instance.unmount()\n    instance._container.innerHTML = ''\n    instance = null\n    router = null\n    history.destroy()\n  },\n  update() {\n    console.log('update')\n  }\n})\n\nif (!qiankunWindow.__POWERED_BY_QIANKUN__) {\n  render(undefined)\n}\n```\n\n> 最后在建立对应的路由即可完成主应用对子应用的跳转\n>\n",
        "date": "2024-04-14T11:25:22.000Z",
        "remark": null,
        "authId": 1,
        "abstract": "\n微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\n微前端借鉴了微服务的架构理念，将一个庞大的前端应用拆分为多个独立灵活的小型应用，每个应用都可以独立开发...",
        "tags": "1",
        "disabled": 1
      },
      "categoryId": 0
    },
    {
      "articleId": 50,
      "articles": {
        "id": 50,
        "title": "前端一些实用插件",
        "text": "1. vuedraggable官方文档地址：[https://www.itxst.com/vue-draggable/j6vzfv6r.html](https://www.itxst.com/vue-draggable/j6vzfv6r.html)\n\n> 在线示例[https://sortablejs.github.io/Vue.Draggable/#/two-list-headerslots](https://sortablejs.github.io/Vue.Draggable/#/two-list-headerslots) Vue3 DnD拖拽 [Home | Vue3 DnD (vue3-dnd.com)](https://www.vue3-dnd.com/)\n\n2. 开源 Web 富文本编辑器，开箱即用，配置简单 [http://www.wangeditor.com/](http://www.wangeditor.com/)\n3. 直播视频video.js  [https://github.com/videojs/video.js](https://github.com/videojs/video.js)\n4. Markdown 编辑器 [Vditor](https://b3log.org/vditor) 是一款浏览器端的编辑器 [https://b3log.org/vditor/](https://b3log.org/vditor/)\n5. lodash模块化、高性能的 JavaScript 实用工具库 [https://www.lodashjs.com/](https://www.lodashjs.com/)\n6. Echarts Demo合集 [https://www.isqqw.com/](https://www.isqqw.com/)\n7. 西瓜播放器 [https://v2.h5player.bytedance.com/](https://v2.h5player.bytedance.com/)\n8. 思维导图 [https://docs.jsplumbtoolkit.com/toolkit/6.x/](https://docs.jsplumbtoolkit.com/toolkit/6.x/)\n\n> 中文在线文档 [https://wdd.js.org/jsplumb-chinese-tutorial/#/](https://wdd.js.org/jsplumb-chinese-tutorial/#/)\n\n9. 各种格式转换文件 [https://convertio.co/zh/](https://convertio.co/zh/)\n10. 阿里云提供地图的JSON数据 [http://datav.aliyun.com/portal/school/atlas/area\\_selector](http://datav.aliyun.com/portal/school/atlas/area_selector)\n11. typescript学习答题 [关于本文档 | TS 类型挑战通关手册 (maxiaobo.com.cn)](https://blog.maxiaobo.com.cn/type-challenge/dist/)\n\n后续找到好用的在加\n",
        "date": "2024-04-14T12:44:39.000Z",
        "remark": "备注",
        "authId": 3,
        "abstract": "\nvuedraggable官方文档地址：https://www.itxst.com/vue-draggable/j6vzfv6r.html\n\n\n在线示例https://sortablejs.githu...",
        "tags": "1,2",
        "disabled": 1
      },
      "categoryId": 0
    },
    {
      "articleId": 63,
      "articles": {
        "id": 63,
        "title": "next.js如何优雅的使用prisma",
        "text": "### Next.js\n\n> 本次使用的next项目的版本为 `14.2.1` , 使用的全新路由 `App Router` 交互 前端路由next项目自动化路由，只需在 `app` 下新建文件夹，然后文件夹下新建 `page.tsx` 或者 `page.jsx` 官网地址：[Next.js v14.2.1 文档](https://link.juejin.cn?target=https%3A%2F%2Fnextjs.org%2Fdocs \"https://nextjs.org/docs\"){:target=\"\\_blank\"}\n\n* `next.js`专门为构建高效、动态的服务器端渲染（SSR）或静态生成（SSG）的 React 应用程序而设计\n* Next.js 是一个用于构建全栈 Web 应用程序的 React 框架。您可以使用 React 组件来构建用户界面，并Next.js其他功能和优化\n* 在后台，Next.js 还抽象并自动配置 React 所需的工具，例如捆绑、编译等。这使您可以专注于构建应用程序，而不是花时间进行配置\n* 无论您是个人开发人员还是大型团队的一员，Next.js 都可以帮助您构建交互式、动态且快速的 React 应用程序\n\n1. 使用官方脚手架 `create-next-app` 创建一个项目\n\n>> node版本需要 `18.17` 及以上，运行下面命令，会提示输入项目名称，选择是否TS...等\n>>\n\n```bash\nnpx create-next-app@latest\n```\n\n2. 运行项目、查看 `http://localhost:3000`\n\n```bash\nnpm run dev\n```\n\n3. 编辑（或）文件并保存它以在浏览器中查看更新的结果\n\n>> `app/page.tsx`或`pages/index.tsx`\n>>\n\n### Prisma\n\n> `Prisma` 是一个现代的开源 ORM（对象关系映射）工具和数据库访问引擎，专为 `TypeScript` 和 `JavaScript` 开发者设计，用于简化与数据库的交互 对于前端不会 `sql` 语句的非常友好 (尤其是对于笔者这种不会sql的，简直不要太舒服)\n\n1. 在 `next.js` 项目中安装 `prisma`\n\n```bash\nnpm install prisma --save-dev\n```\n\n2. 使用 `Prisma CLI` 的命令设置 `Prisma ORM`：`init`\n\n>> 这将创建一个包含 Prisma 架构文件的新目录，并将 mysql 配置为数据库。\n>>\n\n```bash\nnpx prisma init --datasource-provider mysql\n```\n\n3. 修改 `env` 文件，改成自己数据库账号密码以及地址\n\n```bash\nDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public\"\n```\n\n4. 在 `Prisma` 架构中对数据表结构进行建模\n\n>> 在 `prisma` 目录下的 `schema.prisma` 文件添加模型（模型和数据库结构一致）\n>>\n\n```javascript\nmodel Category {\n  id    Int     @id @default(autoincrement())\n  tagName String\n  cTime  DateTime?\n  uTime  DateTime?\n  disabled Int?\n  \n  @@map(\"category\") // 表名---使用 @map() 重新映射为了下划线命名，使用时候只需要 category 即可\n}\n```\n\n5. 保存并运行`schema.prisma` (这个文件夹有更新都需要重新运行一遍这个命令)\n\n```bash\nnpx prisma generate\n```\n\n6. `next` 项目根目录下创建 `pages\\api` 文件夹里面新建一个 `category.ts` 会自动生成一个 `/api/category` 接口\n\n```typescript\nimport { PrismaClient } from '@prisma/client';\nimport { NextApiRequest, NextApiResponse } from 'next';\n\nconst prisma = new PrismaClient();\n\nexport default async function fetchSomeData(req: NextApiRequest, res: NextApiResponse) {\n  const data = await prisma.category.findMany()\n  res.status(200).json({ code: 200, data })\n}\n```\n\n7. 浏览器访问一下 `http://localhost:3000/api/category` 数据库对应的数据就来了\n\n> 以上就是 `next` 和 `prisma` 简单的入门\n",
        "date": "2024-04-28T09:04:10.000Z",
        "remark": "全栈1",
        "authId": 3,
        "abstract": "Next.js\n\n本次使用的next项目的版本为 14.2.1 , 使用的全新路由 App Router 交互 前端路由next项目自动化路由，只需在 app 下新建文件夹，然后文件夹下新建 page...",
        "tags": "1,2",
        "disabled": null
      },
      "categoryId": 0
    },
    {
      "articleId": 64,
      "articles": {
        "id": 64,
        "title": "新建一个测试",
        "text": "新建一个测试内容，测试内容为xxxx，测试文章内容的展示，移动端的展示，展示完再删掉\n",
        "date": "2024-05-01T14:46:42.000Z",
        "remark": "",
        "authId": 1,
        "abstract": "新建一个测试内容，测试内容为xxxx，测试文章内容的展示，移动端的展示，展示完再删掉\n",
        "tags": "2",
        "disabled": null
      },
      "categoryId": 0
    }
  ]
}